#! /usr/bin/env python
# -*- coding: iso-8859-1 -*-

# chimera - observatory automation system
# Copyright (C) 2006-2007  P. Henrique Silva <henrique@astro.ufsc.br>

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import sys
import os
import time
import logging
import signal
import copy
import threading
import warnings
import socket

from types import StringType, ListType, TupleType

import Pyro.util

from optparse import OptionParser, OptionGroup

from chimera.core.manager import Manager
from chimera.core.version import _chimera_version_, _chimera_description_
from chimera.core.constants import MANAGER_DEFAULT_HOST, MANAGER_DEFAULT_PORT

from chimera.instruments.camera import Camera
from chimera.instruments.filterwheel import FilterWheel
from chimera.interfaces.camera import Shutter
from chimera.interfaces.cameradriver import CameraFeature

from chimera.core.exceptions import ObjectNotFoundException
from chimera.core.exceptions import ChimeraObjectException
from chimera.core.exceptions import InvalidLocationException
from chimera.core.exceptions import ClassLoaderException
from chimera.core.exceptions import printException

from chimera.interfaces.filterwheel import InvalidFilterPositionException

from chimera.core.location import Location
from chimera.core.path     import ChimeraPath
from chimera.core.callback import callback

from chimera.core.log import setConsoleLevel
#setConsoleLevel(logging.DEBUG)
setConsoleLevel(1e9)

if __name__ == '__main__':

    chimera_cam_description = " - Camera controller"


    def check_includepath (option, opt_str, value, parser):
        if not value or not os.path.isdir (os.path.abspath(value)):
            raise optparse.OptionValueError ("Couldn't found %s include path." % value)
        eval ('parser.values.%s.append ("%s")' % (option.dest, value))

    def check_location (option, opt_str, value, parser):
        try:
            l = Location (value)
        except InvalidLocationException:
            raise optparse.OptionValueError ("%s isnt't a valid location." % value)

        eval ('parser.values.%s.append ("%s")' % (option.dest, value))


    parser = OptionParser(prog="chimera-cam", version=_chimera_version_,
                          description=_chimera_description_+chimera_cam_description)

    config = OptionGroup(parser, "Camera and driver configuration")

    config.add_option("-c", "--camera", action="callback", type="string", dest="camera",
                      help="Camera instrument to be used. If blank, create a new"
                      " camera instance, using the the driver selected with --driver."
                      " format: [host:port]/Class/name.",
                      callback=check_location)

    config.add_option("-W", "--wheel", action="callback", type="string", dest="wheel",
                      help="Camera instrument to be used. If blank, create a new"
                      " camera instance, using the the driver selected with --driver."
                      " format: [host:port]/Class/name.",
                      callback=check_location)

    config.add_option("-d", "--driver", action="callback", type="string", dest="driver",
                      help="Camera driver to be used."
                      " /Class/name?option1=value1,option2=value. [default=%default]",
                      callback=check_location)

    config.add_option("-D", "--drivers-dir", action="callback", callback=check_includepath,
                      dest="drv_dir", type="string",
                      help="Append PATH to drivers load path.",
                      metavar="PATH")

    info = OptionGroup(parser, "Information")
    
    info.add_option("--info", action="store_true", dest="info",
                      help="Print camera information and exit")

    info.add_option("-F", "--filters", action="store_true", dest="filters",
                      help="Print available filter names and positions.")

    expose = OptionGroup(parser, "Exposure control")
    
    expose.add_option("-n", "--nexp", action="store", type="int", dest="nexp",
                      help="Number of frames [default=%default].")

    expose.add_option("-t", "--texp", action="store", type="float", dest="texp",
                      help="Integration time in seconds for each frame [default=%default].")

    expose.add_option("-i", "--interval", action="store", type="float", dest="interval",
                      help="Number of seconds to wait between each frame "
                      "[default=%default].")

    expose.add_option("-o", "--output", action="store", type="string", dest="output",
                      help="Base filename without path"
                      "[default=%default]")
    
    expose.add_option("-f", "--filter", action="store", type="string", dest="filter",
                      help="Filter to be used. Use filter name. "
                      "Use --filters to get a list of available filters")
    
    expose.add_option("-s", "--shutter", action="store", type="choice", dest="shutter",
                      choices=["open", "OPEN", "close", "CLOSE", "leave", "LEAVE"],
                      help="What to do with the shutter: open, close, leave (case insensitive) [default=%default]")

    expose.add_option("--binning", action="store", type="string", dest="binning",
                      help="Apply the selected binning to all frames")

    expose.add_option("--subframe", action="store", type="string", dest="subframe",
                      help="Readout only the selected subframe portion. The notation follows IRAF conventions."
                      " x1:x2,y1:y2 to specify the corners of the desired subframe")

    temp = OptionGroup(parser, "Temperature control")
    
    temp.add_option("-T", "--setpoint", action="store", type="float", dest="SetPoint",
                      help="Enable CCD cooling with TEMP as setpoint.", metavar="TEMP")

    temp.add_option("-w", "--wait", action="store_true", dest="wait",
                      help="Wait until the selected CCD setpoint is achived."
                      "[default=%default].")

    temp.add_option("--disable-cooling", action="store_true",
                      dest="disable_cooling",
                      help="Disable camera cooling. [default=%default].")


    temp.add_option("--stop-fan", action="store_true", dest="stop_fan",
                      help="Stop the cooler fan.")


    temp.add_option("--start-fan", action="store_true", dest="start_fan",
                      help="Start the cooler fan.")


    imagetyp = OptionGroup(parser, "Image types")

    
    imagetyp.add_option("--bias", action="store_const", dest="imagetyp", const="zero",
                        help="Mark this frame as a BIAS frame.")

    imagetyp.add_option("--dark", action="store_const", dest="imagetyp", const="dark",
                        help="Mark this frame as a DARK frame.")

    imagetyp.add_option("--flat", action="store_const", dest="imagetyp", const="flat",
                        help="Mark this frame as a FLAT frame.")

    imagetyp.add_option("--object", action="store_const", dest="imagetyp", const="object",
                        help="Mark this frame as a OBJECT frame.")


    display = OptionGroup(parser, "Display configuration")
    display.add_option("--no-display", action="store_true", dest="no_display",
                      help="Don't try to display image on DS9. default is display for exptime >= 5")

    display.add_option("--force-display", action="store_true", dest="force_display",
                      help="Always display image on DS9 regardless of exptime.")

    parser.add_option("-H", "--host", action="store", 
                      dest="pyro_host", type="string",
                      help="Host name/IP to run instrument under when using local manager"
                      "; [default=%default]",
                      metavar="HOST")

    parser.add_option("-P", "--port", action="store", 
                      dest="pyro_port", type="string",
                      help="Port on which to to run instrument under when using local manager"
                      "; [default=%default]",
                      metavar="PORT")

    parser.add_option("-q", "--quiet", action="store_true", dest='quiet',
                      help="Don't display information during the exposures [default=%default].")

    parser.add_option_group(config)
    parser.add_option_group(info)
    parser.add_option_group(expose)
    parser.add_option_group(display)    
    parser.add_option_group(imagetyp)    
    parser.add_option_group(temp)

    parser.set_defaults(camera   = [],
                        driver   = ["/FakeCamera/fc"],
                        drv_dir  = [],
                        wheel    = [],
                        nexp     = 1,
                        texp     = 1,
                        interval = 0,
                        output   = "$DATE-$TIME",
                        shutter  = "open",
                        no_display  = False,
                        force_display = False, 
                        quiet    = False,
                        imagetyp="object",
                        binning = "",
                        subframe= "",
                        disable_cooling  = False ,
                        SetPoint = -500, # magic number
                        wait     = False,
                        start_fan = False,
                        stop_fan = False,
                        filter   = None,
                        filters  = False,
                        info     = False,
                        
                        pyro_host=MANAGER_DEFAULT_HOST,
                        pyro_port=10000)

    options, args = parser.parse_args(sys.argv)

    # some validations

    if options.nexp < 0:
        print >> sys.stderr, "--nexp must be a positive number."
        sys.exit(1)

    if options.texp < 0:
        print >> sys.stderr, "--texp must be a positive number."
        sys.exit(1)

    if options.shutter.lower() == "open":
        options.shutter = Shutter.OPEN
    elif options.shutter.lower() == "close":
        options.shutter = Shutter.CLOSE
    elif options.shutter.lower() == "leave":
        options.shutter = Shutter.LEAVE_AS_IS
    else:
        options.shutter = Shutter.OPEN

    drivers_path = []
    for path in options.drv_dir:
        drivers_path.append(path)

    drivers_path.append(ChimeraPath.drivers())

    # be cool?
    cooling  = None
    SetPoint = 10 # FIXME: magic number

    if options.SetPoint != -500:
        cooling = True
        SetPoint = options.SetPoint

    if options.disable_cooling:
        cooling  = False
        SetPoint = None

    # filter
    filter = None

    # DS9 setup

    has_ds9 = False
    ds9 = None
    display = False
    
    # FIXME: display broken
    #options.no_display = True

    if (not options.no_display and options.texp >= 5) or options.force_display:

        try:

            # disable RO warning
            warnings.filterwarnings(action='ignore', module='RO.DS9')

            from RO.DS9 import DS9Win as DS9
            
            has_ds9 = True
        except ImportError:
            print >> sys.stderr, 40*"="
            print >> sys.stderr, "DS9 is not available. Display disabled"
            
        if has_ds9:

            try:
                ds9 = DS9 (doRaise=True, doOpen=True)
                display = True
            except RuntimeError, e:
                # even with RO installed, we still need XPA package to get DS9 working
                print >> sys.stderr, 40*"="                
                print >> sys.stderr, "DS9 is not available, check if you have the XPA package installed. Display disabled."
                print >> sys.stderr, str(e)
                display = False

    # 
    # start
    #

    manager = Manager(host=options.pyro_host,port=options.pyro_port)

    camera = None
    driver = None
    
    filter = None

    # ctrl+c handling
    aborted = False

    def sighandler(self, sig = None, frame = None):

        global aborted
        
        if aborted == False:
            aborted = True
        else:
            return
            
        print >> sys.stdout, "aborting... "
        sys.stdout.flush()

        def abort():
            cam = copy.copy(camera)
            if cam.isExposing():
                cam.abortExposure()

        t = threading.Thread(target=abort)
        t.start()
        t.join()
            
    signal.signal(signal.SIGTERM, sighandler)
    signal.signal(signal.SIGINT, sighandler)

    # use an already running camera
    if options.camera:
        try:
            camera = manager.getProxy(options.camera[0])
            driver = camera.getDriver()
            if options.wheel:
                filter = manager.getProxy(options.wheel[0])
            else:
                filter = manager.getProxy(options.camera[0])

        except (ObjectNotFoundException, ClassLoaderException), e:
            print >> sys.stderr, "Cannot find camera %s. (%s)" % (options.camera[0], e)
            manager.shutdown()
            sys.exit(1)
        except (ChimeraObjectException), e:
            print >> sys.stderr, "Problems starting camera %s. (%s)" % (options.camera[0],e)
            manager.shutdown()
            sys.exit(1)


    # create a new camera using selected driver
    else:
        try:
            config = {}

            driverloc = Location(options.driver[-1])
            newloc = Location(cls=driverloc.cls, name=driverloc.name, config=dict(driverloc.config, **config),
                              host=driverloc.host, port=driverloc.port)

            if manager._belongsToMe(newloc):
                driver = manager.addLocation(newloc, path=drivers_path)
            else:
                driver = manager.getProxy(newloc)
            camera = manager.addClass(Camera, "cam", {"driver": options.driver[-1]})
            filter = manager.addClass(FilterWheel, "filter", {"driver": options.driver[-1]} )
        except (ObjectNotFoundException, ClassLoaderException), e:
            print >> sys.stderr, "Cannot find camera driver %s. (%s)" % (options.driver[-1],e)
            manager.shutdown()
            sys.exit(1)
        except (ChimeraObjectException), e:
            print >> sys.stderr, "Problems starting camera driver %s. (%s)" % (options.driver[-1],e)
            manager.shutdown()
            sys.exit(1)
    
    def getListContents(list):
        toRet = []
        for l in list:
            if isinstance(l, ListType) or isinstance(l, TupleType):
                toRet+=getListContents(l)
            else:
                if l not in toRet:
                    toRet+=l.lower()
        return toRet

    driverHost = driver.getManager().getHostname().lower()
    localHosts = getListContents(socket.gethostbyname_ex('localhost'))
    localHosts += getListContents(socket.gethostbyname_ex(socket.gethostname()))
    hostIsLocal = (driverHost in localHosts)
    displayedImages = []
    
    # take some exposures

    currentFrame = 0
    currentFrameExposeStart = 0
    currentFrameReadoutStart = 0

    # first check binning
    binnings = camera.getBinnings()

    if options.binning:
        if options.binning not in binnings.keys():
            print >> sys.stderr, "Invalid binning mode. See --info for available binning modes"
            manager.shutdown()
            sys.exit(1)

    @callback(manager)
    def exposeBegin(exptime):
        global currentFrame, currentFrameExposeStart, options
        currentFrameExposeStart = time.time()
        currentFrame += 1
        if not options.quiet:
            print 40*"="
            print "[%03d/%03d] [%s]" % (currentFrame, options.nexp, time.strftime("%c"))
            print "exposing (%.3fs) ..." % exptime,
            sys.stdout.flush()
    
    @callback(manager)
    def exposeComplete():
        global currentFrameExposeStart, options
        if not options.quiet:
            print "OK (took %.3f s)" % (time.time()-currentFrameExposeStart)
            sys.stdout.flush()

    @callback(manager)
    def readoutBegin(filename):
        global currentFrameReadoutStart, options
        currentFrameReadoutStart = time.time()
        if not options.quiet:
            #TODO: How to get the filename
            print "reading out ..."
            sys.stdout.flush()
    
    def imageURItoDS9Path(imageURI):
        global hostIsLocal
        if hostIsLocal:
            return imageURI.getProxy().getPath()
        else:
            return "url '%s'" % imageURI.getHttpUri()
    
    def displayPath(path):
        global displayedImages, display
        if path not in displayedImages and display:
            displayedImages += path
            print 'Trying to display "%s" ...' % path
            try:
                ds9.xpaset('file %s' % path)
            except RuntimeError, e:
                #print >> sys.stderr, "Can't display image %s. (%s)" % (path,e)
                pass    #Issue with xpaset prevents us from assuming that this failed!        

    @callback(manager)
    def readoutComplete(imageURI):
        global currentFrameReadoutStart, currentFrameExposeStart, options, display, ds9
        global currentFrame

        if not options.quiet:
            print "OK (took %.3f s)"  % (time.time()-currentFrameReadoutStart)
            print "[%03d/%03d] took %.3fs" % (currentFrame, options.nexp,
                                              time.time()-currentFrameExposeStart)
            sys.stdout.flush()
        
        if display:
            displayPath(imageURItoDS9Path(imageURI))

    camera.exposeBegin     += exposeBegin
    camera.exposeComplete  += exposeComplete
    camera.readoutBegin    += readoutBegin
    camera.readoutComplete += readoutComplete

    if options.info and not options.quiet:
        print "Camera:", camera["driver"], "(%s)" % driver["device"]

        if camera.isCooling() == True:
            print "Cooling enabled, SetPoint: %.3f oC" % SetPoint
        else:
            print "Cooling disabled."

        print "Current CCD temperature:", camera.getTemperature(), "oC"
        if camera.isFanning():
            print "Cooler fan active."
        else:
            print "Cooler fan inactive."

        print "="*40
        for feature in CameraFeature:
            print str(feature), camera.supports(feature)

        print "="*40
        ccds = camera.getCCDs()
        currentCCD = camera.getCurrentCCD()
        print "Available CCDs: ",
        for ccd in ccds.keys():
            if ccd == currentCCD:
                print "*%s* " % str(ccd),
            else:
                print "%s " % str(ccd),
        print

        print "="*40
        print "ADCs: ",
        adcs = camera.getADCs()
        for adc in adcs.keys():
            print "%s " % adc,
        print

        print "="*40
        print "CCD size (pixel)       : %d x %d" % camera.getPhysicalSize()
        print "Pixel size (micrometer): %.2f x %.2f" % camera.getPixelSize()
        print "Overscan size (pixel)  : %d x %d" % camera.getOverscanSize()
        
        print "="*40
        print "Available binnings: ",
        sortedBins = binnings.keys()
        sortedBins.sort()

        for bin in sortedBins:
            print "%s " % bin,
        print

        manager.shutdown()
        sys.exit(1)
    
    if options.filters and not options.quiet:
        print "Available filters:",
        for i,f in enumerate(filter.getFilters()):
            print f,
        manager.shutdown()
        sys.exit(1)

    if options.stop_fan:
        print "="*40
        print "Stopping cooler fan... ",
        camera.stopFan()
        print "OK"
        print "="*40
        manager.shutdown()
        sys.exit(1)

    if options.start_fan:
        print "="*40
        print "Starting cooler fan... ",
        camera.startFan()
        print "OK"
        print "="*40
        manager.shutdown()
        sys.exit(1)

    if not options.quiet:

        print 40*"="
        if options.camera:
            print "Taking %d %s frame[s] of %.3fs each on %s" % (options.nexp, options.imagetyp.capitalize(),
                                                              options.texp, options.camera[0])
        else:
            print "Taking %d %s frame[s] of %.3fs each using %s" % (options.nexp, options.imagetyp.capitalize(),
                                                                 options.texp, options.driver[-1])
        print "Shutter: %s" % options.shutter
        print "Interval between frames: %.3fs" % options.interval
        if cooling == True:
            print "Cooling enabled, SetPoint: %.3f oC" % SetPoint
        elif cooling == False:
            print "Cooling disabled."
        else:
            print "Leaving cooling as is."

        print "Current CCD temperature:", camera.getTemperature(), "oC"

        if options.filter != None:
            print "Filter: %s" % options.filter

        if options.binning:
            print "Binning: %s" % options.binning
        else:
            print "No binning"

        if options.subframe:
            print "Subframe: %s" % options.subframe
        else:
            print "Full Frame"

        sys.stdout.flush()

    # cooling
    if cooling == True:
        camera.startCooling(SetPoint)
        
    elif cooling == False:
        camera.stopCooling()


    def eps_equal(a, b, eps=0.01):
        return abs(a-b) <= eps

    if cooling == True and options.wait == True:
        timeout = 4*60 # FIXME: configurable?
        start = time.time()

        print 40*"="

        while not eps_equal(camera.getTemperature(), camera.getSetPoint(), 0.2):
            print "\rwaiting SetPoint temperature %.3f oC, current: %.3f oC" \
                % (camera.getSetPoint(), camera.getTemperature()),

            sys.stdout.flush()
            time.sleep(1)

            if time.time() > (start+timeout):
                print "giving up after wait for %d seconds" % timeout
                break

        print "OK (took %.3fs)" % (time.time()-start)
        sys.stdout.flush()

    # filter
    if options.filter != None:
        print 40*"="

        try:
            print "Changing to filter %s... " % options.filter,
            sys.stdout.flush()
            filter.setFilter(options.filter)
            print "OK"
            sys.stdout.flush()
        except InvalidFilterPositionException, e:
            print "ERROR. Couldn't move filter wheel to %s. (%s)" % (options.filter, e)
            time.sleep(5)

    # finally, expose
    start = time.time()

    try:
        imageURIs = []
        try:
            imageURIs = camera.expose(exp_time=options.texp,
                          frames=options.nexp,
                          interval=options.interval,
                          filename=options.output,
                          image_type=options.imagetyp,
                          binning=options.binning or None,
                          window=options.subframe or None,
                          shutter=options.shutter)
        except Exception, e:
            print >> sys.stderr, "Error trying to take exposures. (%s)" % printException(e)
        if not options.quiet and len(imageURIs) > 0:
            displayPath(imageURItoDS9Path(imageURIs[0]))    #Ensure that something gets displayed
            for iURI in imageURIs:
                print 'Frame saved to file://%s:%s%s' % (iURI.host, str(iURI.port), str(iURI.getProxy().getPath()))

    except Exception, e:
            print >> sys.stderr, "Error trying to take exposures. (%s)" % printException(e)                

    #finally: Doesn't work in python2.4 with except block above which prevents silent failures
    camera.exposeBegin     -= exposeBegin
    camera.exposeComplete  -= exposeComplete
    camera.readoutBegin    -= readoutBegin
    camera.readoutComplete -= readoutComplete
    manager.shutdown()

    if not options.quiet and aborted:
        print 40*"="
        print "Took %03d of %03d frames. Aborted by the user." % (currentFrame, options.nexp)

    if not options.quiet:
        print 40*"="
        print "Total time: %.3fs" % (time.time()-start)
        print 40*"="
        print "%s" % time.strftime("%c")            
        print 40*"="

    sys.exit(0)

